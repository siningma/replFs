\documentclass[12pt,fleqn]{article}
\usepackage{graphicx,wrapfig,booktabs,url,bytefield}
\usepackage[margin=1in]{geometry}

\begin{document}
\title{Distributed Replicated Files Protocol Specification}
\author{Sining Ma \\ sma87@stanford.edu}

\maketitle

\section{Protocol Specification}
This section describes all message packets syntax, semantics. All messages bytes are in network byte order. 

\subsection{Common Header}
All packets start with the same header structure.

\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\bitbox{8}{Message Type} & \bitbox{8}{Reserved} \\
		\wordbox{2}{Node Id  ($4$ bytes)} \\
		\wordbox{2}{Sequence Number ($4$ bytes)}
	\end{bytefield}
\end{center}

\begin{description}
	\item[Message Type] The type of Message which is defined in this design.
	\item[Reserved] This field is reserved and should always be zero.
	\item[Node Id] This field represents the unique id for a client or server. Will talk more in Client and Server Id generation section about how this id is generated.
	\item[Sequence Number] Each outgoing packet contains a monotonically increasing sequence number. This number wraps back to zero when it overflows.
\end{description}

\subsection{Init (Message Type 0xC0)}
The client sends Init message when InitReplFs() is called to detect the servers.

\subsection{InitAck (Message Type 0xC1)}
Servers send InitAck messages when the server receives Init message to inform the server's existence. Put the server's id in node id field.

\subsection{OpenFile (Message Type 0xC2)}
The client sends OpenFile message to servers when OpenFile() is called to open a new file on local client file system. Servers open the file based on mount directory and filename.

\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\wordbox{2}{File Id  ($4$ bytes)} \\
		\wordbox{4}{File Name (maximum $128$ bytes including null terminator)}
	\end{bytefield}
\end{center}

\begin{description}
	\item[File Id] File Id generated at client side. This Id is a monotonically increasing number.
	\item[File Name] File name is OpenFile() argument. 
\end{description}

\subsection{OpenFileAck (Message Type 0xC3)}
Servers send OpenFileAck messages to acknowledge OpenFile message. Return 0 if no error. If the server is unavailable or error happens, -1 returns. 

\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\wordbox{2}{File Discriptor ($4$ bytes)} \\
	\end{bytefield}
\end{center}

\begin{description}
	\item[File Descriptor] File descriptor that is used at server side. Returns -1 if error happens, and 0 if no error.
\end{description}

\subsection{WriteBlock (Message Type 0xC4)}
The client sends WriteBlock message when WriteBlock() is called to stage a contiguous chunk of data. No Ack message will be sent from servers. Before one commit, the client can do multiple WriteBlock call to update the file. Update Id is used to mark update sequence id before commit call.

\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\wordbox{2}{File Id ($4$ bytes)} \\
		\wordbox{2}{Update Id  ($4$ bytes)} \\
		\wordbox{2}{Byte Offset  ($4$ bytes)} \\
		\wordbox{2}{Byte Size  ($4$ bytes)} \\
		\wordbox{2}{Buffer  (maximum $512$ bytes)}
	\end{bytefield}
\end{center}

\begin{description}
	\item[File Id] File Id for the opened file at client side.
	\item[Update Id] In one commit, current update id is a monotonically increasing number from 0. Reset back to 0 after one commit.
	\item[Byte Offset] Byte offset the offset within the file to write to.
	\item[Byte Size] Byte size the number of bytes in buffer.
	\item[Buffer] Buffer a pointer to the data to be written.
\end{description}

\subsection{Vote (Message Type 0xC5)}
Two phase commit is used to ensure that all updates in WriteBlock are received on servers. 
The client sends Vote message as the first step in commit request phase to check if all servers receive all updates and are ready to do final commit.
 
\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\wordbox{2}{File Id ($4$ bytes)}
	\end{bytefield}
\end{center}

\begin{description}
	\item[File Id] File Id for the opened file at client side.
\end{description}

\subsection{VoteAck (Message Type 0xC6)}
Servers send VoteAck message with an update Id which indicates the next Update Id that the server needed. When the client receives this message, the client checks if update Id in this message is identical to the total update count. If update id does not match, the client will do message retransmission. If VoteAck message returns -1 file descriptor, abort message will be sent. Will talk more about vote and retransmission in protocol operation flow.

\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\wordbox{2}{File Descriptor ($4$ bytes)} \\
		\wordbox{2}{Update Id  ($4$ bytes)}
	\end{bytefield}
\end{center}

\begin{description}
	\item[File Descriptor] File descriptor that is used at server side. Returns -1 if error happens at the server side, and 0 if no error.
	\item[Update Id] The next update id that is needed on the servers.
\end{description}

\subsection{Commit (Message Type 0xC7)}
The client sends Commit message to all servers to  commit all updates to the file. 

\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\wordbox{2}{File Id ($4$ bytes)}
	\end{bytefield}
\end{center}

\begin{description}
	\item[File Id] File Id for the opened file.
\end{description}

\subsection{CommitAck (Message Type 0xC8)}
Servers send CommitAck message to tell the client which updates have been received.

\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\wordbox{2}{File Descriptor ($4$ bytes)}
	\end{bytefield}
\end{center}

\begin{description}
	\item[File Descriptor] File descriptor that is used at server side. Returns -1 if error happens at the server side, and 0 if no error.
\end{description}

\subsection{Abort (Message Type 0xC9)}
The client sends Abort message to all the servers when receive VoteAck message with -1 file descriptor or client wants to do rollback. All servers undo this transaction and rollback file updates.

\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\wordbox{2}{File Id ($4$ bytes)}
	\end{bytefield}
\end{center}

\begin{description}
	\item[File Id] File Id for the opened file at client side.
\end{description}

\subsection{AbortAck (Message Type 0xCA)}
Servers sends AbortAck message to the client. This message informs the client that the server completes file rollback.

\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\wordbox{2}{File Descriptor ($4$ bytes)}
	\end{bytefield}
\end{center}

\begin{description}
	\item[File Descriptor] File descriptor that is used at server side. Returns -1 if error happens at the server side, and 0 if no error.
\end{description}

\subsection{Close (Message Type 0xCB)}
The client sends Close message to the servers to close the opened file.

\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\wordbox{2}{File Id ($4$ bytes)}
	\end{bytefield}
\end{center}

\begin{description}
	\item[File Id] File Id for the opened file at client side.
\end{description}

\subsection{CloseAck (Message Type 0xCC)}
Servers send CloseAck message to indicate the file is closed.

\begin{center}
	\begin{bytefield}[bitwidth=1.1em]{16}
		\bitheader{0,7,8,15} \\
		\wordbox{2}{File Descriptor ($4$ bytes)}
	\end{bytefield}
\end{center}

\begin{description}
	\item[File Descriptor] File descriptor that is used at server side. Returns -1 if error happens and 0 if no error.
\end{description}

\section{Protocol Details}

\subsection{Client and Server Id generation}
Client and server Ids are generated randomly as a 32-bit integer with a good seed for number generator. The probability of conflict is 5.32101e-20. This is negligible. In real world settings, each client or server is assigned an unique identifier, e.g. UUID.

\subsection{File Id generation}
File Id on the client side is a monotonically increasing number starting from 0.

\subsection{Protocol Operation Flow}
\begin{itemize}
	\item On InitReplFs(), the client sends init message to the multicast group to detect if there are enough servers in init timeout time. If responding servers count is smaller than numServers, the client returns error. Otherwise, if there are more servers, the client selects the first numServers, and only accepts acknowledge messages from these selected servers.
	\item On OpenFile(), the client sends OpenFile message to servers to open a file and waits for OpenFileAck messages.
	\item OpenFileAck message is sent from the servers. If file Id is -1, this means that OpenFile fails and the client returns error. If response selected servers count is less than init phase servers count, the client returns error. The assumption is that there is only one client running, so no need to cache client id on servers.
	\item On WriteBlock() sends WriteBlock file update message to the servers without acknowledge. Client caches all the updates before one commit. Each server caches all the received updates before receiving commit messages.
	\item On Commit(), the client sends vote message to all servers, and waits for vote response. Servers receive vote message. Servers store the next needed update id. Servers check from the latest valid update number one by one to see if the next update is received. If the next id is not received, servers send VoteAck message with the next needed update Id. If all updates received, servers still send the next update Id. Client must make sure the returned update id matches all update count. Any error happens on the server side, VoteAck message returns -1 file descriptor. \\ 
	Give one example. The client sends update 0, 1, 2, 3 to the servers, so the client total updates count is 4. If the server receives update 0, 1, 3, but 2 is lost, this server's next update id is 2. VoteAck message returns not -1 file descriptor, and next update id is 2. Client will do retransmission.
	\item Retransmission. Client receives VoteAck messages after receiving all servers VoteAck messages or timeout. Client reads all update ids and finds the smallest update id. Client starts to do retransmission from the smallest update id to all the remaining WriteBlock. Servers update received update cache. Client sends vote message again when all remaining WriteBlock is done.
	\item When Client receives all servers VoteAck message with update id matching servers total update count. Client sends commit message to complete this transaction. If client receives VoteAck message with -1 file descriptor, client sends Abort message. Any server timeouts for VoteAck message, client sends Abort message.
	\item The client sends Commit or Abort message to servers to complete the transaction or rollback. The client waits CommitAck or AbortAck message. If this is commit message, servers update the file with all update in the cache sequentially.
	\item On Abort(), the client sends abort message to servers. Waits for AbortAck messages.
	\item The client receives CommitAck or AbortAck message. The client returns error if file descriptor is -1 or receiving messages timeout. 
	\item On Close(), the client sends close message to close the file. The client returns error if file descriptor is -1 or not sufficient server CloseAck messages are received in timeout time.
\end{itemize}

\subsection{Protocol Timing}
\subsubsection{InitReplFs}
The client sends Init messages to servers every 200ms, and client waits for 2s. The client only accepts servers InitAck message in init phase timeout. 

\subsubsection{OpenFile}
The client sends OpenFile messages to servers every 200ms. OpenFile phase timeout is 4s. The client returns -1 if not sufficient server OpenFileAck messages are received in this 4s timeout time.

\subsubsection{Vote}
The client sends Vote messages to servers every 200ms, and Vote phase timeout is 4s. If any server has no response in 4s, the client treats this case as replies VoteAck message with -1 file description. The client sends abort message.

\subsubsection{Commit and Abort}
The client sends Commit or Abort messages to servers every 200ms, this Commit or Abort timeout is 4s. If any server has no response in 4s, the client returns error but servers keep the commit that has already committed. On the server side, if any server cannot receive any commit and abort message in commit or abort phase for 4 seconds, the server rollbacks file updates automatically.
 
 \subsubsection{Close}
The client sends Close messages to servers every 200ms, and Close phase timeout is 2s. The client returns -1 if not sufficient server CloseAck messages are received.
 
\end{document}